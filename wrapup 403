import com.mypurecloud.sdk.v2.ApiClient;
import com.mypurecloud.sdk.v2.ApiException;
import com.mypurecloud.sdk.v2.Configuration;
import com.mypurecloud.sdk.v2.api.ConversationsApi;
import com.mypurecloud.sdk.v2.model.ErrorBody;import com.mypurecloud.sdk.v2.model.MediaParticipantRequest;

public class ExamplepatchConversationsCallbackParticipant {
    public static void main(String[] args) {
        // Create ApiClient instance
        ApiClient apiClient = ApiClient.Builder.standard()
                .withAccessToken("your_access_token")   // or use authorizeClientCredentials(...), authorizeCodeAuthorization(...), authorizePKCE(...) or authorizeSaml2Bearer(...)
                .withBasePath("https://api.mypurecloud.com") // expected format: https://api.[base path]
                .build();
        
        // Use the ApiClient instance
        Configuration.setDefaultApiClient(apiClient);

        ConversationsApi apiInstance = new ConversationsApi();
        String conversationId = "conversationId_example"; // String | conversationId
String participantId = "participantId_example"; // String | participantId
MediaParticipantRequest body = new MediaParticipantRequest(); // MediaParticipantRequest | Participant
        try { 
            // Update conversation participant
            apiInstance.patchConversationsCallbackParticipant(conversationId, participantId, body);
        } catch (ApiException e) {
            System.err.println("Exception when calling ConversationsApi#patchConversationsCallbackParticipant");
            e.printStackTrace();
        }
    }
}


Resource Authorization
This resource requires authorization via Genesys Cloud OAuth. Read more about this authorization type at Platform API Client Authorization.

Required Permissions
Apps making this request must have ANY of these permissions:

conversation:participant:wrapup
conversation:call:record
conversation:communication:disconnect
Required Scopes
Apps making this request must have any of these scopes:

conversations
Resource Limits
The following limits apply to this resource. For more information, see the main article on Rate Limits and the full list of Platform API Limits.

Key
Description
Limit
Resource(s)
Configurable?
token.rate.per.minute
The maximum number of requests per token per minute
300
api/v2/*
no
request.bytes.max
The maximum content length of a request payload
512000
api/v2/*
no
org.app.user.rate.per.minute
The maximum number of requests a user is allowed, per minute, with a specific Authorization Code or Token Implicit OAuth client grant
3000
api/v2/*
no
client.credentials.token.rate.per.minute
The maximum number of requests a Client Credentials grant token is allowed per minute
300
api/v2/*
yes










































package com.demsIB.integration.genesys.service.impl;

import com.mypurecloud.sdk.v2.ApiClient;
import com.mypurecloud.sdk.v2.ApiException;
import com.mypurecloud.sdk.v2.Configuration;
import com.mypurecloud.sdk.v2.api.ConversationsApi;
import com.mypurecloud.sdk.v2.model.*;
import com.demsIB.integration.genesys.dto.request.WrapupRequest;
import com.demsIB.integration.genesys.dto.response.WrapupFinalResponse;
import com.demsIB.integration.genesys.exception.GenesysIntegrationException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.stream.Collectors;

@Service
public class GenesysSdkService {

    private static final Logger logger = LoggerFactory.getLogger(GenesysSdkService.class);

    private final ConversationsApi conversationsApi;
    private final AnalyticsApi analyticsApi;

    public GenesysSdkService() {
        // Initialize the SDK client
        ApiClient apiClient = ApiClient.Builder.standard()
                .withBasePath("https://api.aps1.pure.cloud")
                .build();
        
        Configuration.setDefaultApiClient(apiClient);
        
        this.conversationsApi = new ConversationsApi();
        this.analyticsApi = new AnalyticsApi();
    }

    // Set access token (call this before any operations)
    public void setAccessToken(String accessToken) {
        ApiClient defaultClient = Configuration.getDefaultApiClient();
        defaultClient.setAccessToken(accessToken);
    }

    // Complete wrap-up flow using SDK
    public void executeCompleteWrapupFlow(String conversationId, WrapupRequest wrapupRequest) {
        try {
            logger.info("Starting complete wrapup flow for conversation: {}", conversationId);
            
            // Step 1: Get agent participant info
            Map<String, String> agentInfo = getAgentParticipantInfo(conversationId);
            String participantId = agentInfo.get("participantId");
            
            logger.info("Found agent participant - ID: {}", participantId);
            
            // Step 2: Get wrap-up codes and find the matching code ID
            String wrapupCodeId = findWrapupCodeId(conversationId, participantId, wrapupRequest.getName());
            
            // Step 3: Update participant wrap-up
            updateParticipantWrapup(conversationId, participantId, wrapupRequest, wrapupCodeId);
            
            logger.info("Complete wrapup flow finished successfully for conversation: {}", conversationId);
            
        } catch (ApiException e) {
            handleApiException(e, "complete wrapup flow");
        }
    }

    // Get agent participant information
    private Map<String, String> getAgentParticipantInfo(String conversationId) throws ApiException {
        logger.debug("Getting conversation details for: {}", conversationId);
        
        // Get conversation details
        Conversation conversation = conversationsApi.getConversation(conversationId);
        
        if (conversation != null && conversation.getParticipants() != null) {
            for (Participant participant : conversation.getParticipants()) {
                if (participant.getPurpose() != null && "agent".equals(participant.getPurpose())) {
                    Map<String, String> agentInfo = new HashMap<>();
                    agentInfo.put("participantId", participant.getId());
                    if (participant.getUserId() != null) {
                        agentInfo.put("userId", participant.getUserId());
                    }
                    return agentInfo;
                }
            }
        }
        
        throw new GenesysIntegrationException("Agent participant not found for conversation: " + conversationId, 
                                            404);
    }

    // Get wrap-up codes and find matching code ID
    private String findWrapupCodeId(String conversationId, String participantId, String wrapupName) throws ApiException {
        logger.debug("Getting wrap-up codes for participant: {}", participantId);
        
        // Get wrap-up codes for the participant
        List<WrapupCode> wrapupCodes = conversationsApi.getConversationsCallbacksParticipantWrapupcodes(
            conversationId, participantId);
        
        return wrapupCodes.stream()
            .filter(code -> wrapupName.equals(code.getName()))
            .findFirst()
            .map(WrapupCode::getId)
            .orElseThrow(() -> new GenesysIntegrationException(
                "Wrap-up code not found for name: " + wrapupName, 404));
    }

    // Update participant wrap-up
    private void updateParticipantWrapup(String conversationId, String participantId, 
                                       WrapupRequest wrapupRequest, String wrapupCodeId) throws ApiException {
        logger.debug("Updating wrap-up for participant: {} with code: {}", participantId, wrapupCodeId);
        
        MediaParticipantRequest participantRequest = new MediaParticipantRequest();
        
        // Create wrap-up details
        Wrapup wrapup = new Wrapup();
        wrapup.setCode(wrapupCodeId);
        wrapup.setName(wrapupRequest.getName());
        wrapup.setNotes(wrapupRequest.getNotes());
        wrapup.setTags(Arrays.asList()); // Add tags if needed
        
        participantRequest.setWrapup(wrapup);
        
        // Update the participant
        conversationsApi.patchConversationsCallbackParticipant(
            conversationId, participantId, participantRequest);
        
        logger.info("Successfully updated wrap-up for participant: {} in conversation: {}", 
                   participantId, conversationId);
    }

    // Handle API exceptions
    private void handleApiException(ApiException e, String operation) {
        logger.error("Genesys API error during {}: Status={}, Message={}", 
                    operation, e.getCode(), e.getMessage());
        
        if (e.getCode() == 403) {
            throw new GenesysIntegrationException(
                "Access denied. Please check OAuth client permissions and scopes. " +
                "Required permissions: conversation:participant:wrapup, conversation:call:record, conversation:communication:disconnect. " +
                "Required scope: conversations", 403);
        } else if (e.getCode() == 401) {
            throw new GenesysIntegrationException("Authentication failed. Please check access token.", 401);
        } else if (e.getCode() == 404) {
            throw new GenesysIntegrationException("Resource not found: " + e.getMessage(), 404);
        } else {
            throw new GenesysIntegrationException("Genesys API error: " + e.getMessage(), e.getCode());
        }
    }
}



package com.demsIB.integration.genesys.service.impl;

import com.demsIB.integration.genesys.config.GenesysProperties;
import com.mypurecloud.sdk.v2.ApiClient;
import com.mypurecloud.sdk.v2.ApiException;
import com.mypurecloud.sdk.v2.ApiResponse;
import com.mypurecloud.sdk.v2.auth.OAuth;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.http.*;
import org.springframework.stereotype.Service;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MultiValueMap;
import org.springframework.web.client.RestTemplate;

import java.time.LocalDateTime;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.locks.ReentrantLock;

@Service
public class GenesysSdkAuthService {

    private static final Logger logger = LoggerFactory.getLogger(GenesysSdkAuthService.class);

    private final RestTemplate restTemplate;
    private final GenesysProperties genesysProperties;
    private final GenesysSdkService genesysSdkService;
    
    private final Map<String, TokenInfo> tokenCache = new ConcurrentHashMap<>();
    private final ReentrantLock tokenLock = new ReentrantLock();
    private static final String SYSTEM_TOKEN_KEY = "SYSTEM";

    public GenesysSdkAuthService(@Qualifier("genesysRestTemplate") RestTemplate restTemplate,
                                GenesysProperties genesysProperties,
                                GenesysSdkService genesysSdkService) {
        this.restTemplate = restTemplate;
        this.genesysProperties = genesysProperties;
        this.genesysSdkService = genesysSdkService;
    }

    // Authenticate and setup SDK
    public void authenticateAndSetupSdk() {
        String accessToken = getConsistentSystemToken();
        genesysSdkService.setAccessToken(accessToken);
        logger.info("Genesys SDK authenticated and ready");
    }

    // Get consistent system access token
    public String getConsistentSystemToken() {
        tokenLock.lock();
        try {
            TokenInfo tokenInfo = tokenCache.get(SYSTEM_TOKEN_KEY);
            
            if (tokenInfo == null || isTokenExpiredOrExpiring(tokenInfo)) {
                logger.info("Refreshing system access token");
                tokenInfo = fetchNewToken();
                tokenCache.put(SYSTEM_TOKEN_KEY, tokenInfo);
                logger.info("New system access token acquired");
            }
            
            return tokenInfo.getAccessToken();
            
        } finally {
            tokenLock.unlock();
        }
    }

    private boolean isTokenExpiredOrExpiring(TokenInfo tokenInfo) {
        LocalDateTime refreshThreshold = tokenInfo.getExpiryTime()
                .minusMinutes(genesysProperties.getTokenRefreshThresholdMinutes());
        return LocalDateTime.now().isAfter(refreshThreshold);
    }

    private TokenInfo fetchNewToken() {
        try {
            HttpHeaders headers = new HttpHeaders();
            headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);

            MultiValueMap<String, String> body = new LinkedMultiValueMap<>();
            body.add("grant_type", "client_credentials");
            body.add("client_id", genesysProperties.getClientId());
            body.add("client_secret", genesysProperties.getClientSecret());

            HttpEntity<MultiValueMap<String, String>> requestEntity = new HttpEntity<>(body, headers);

            ResponseEntity<Map> response = restTemplate.exchange(
                    genesysProperties.getTokenUrl(),
                    HttpMethod.POST,
                    requestEntity,
                    Map.class
            );

            if (response.getStatusCode().is2xxSuccessful() && response.getBody() != null) {
                Map<String, Object> responseBody = response.getBody();
                String accessToken = (String) responseBody.get("access_token");
                Integer expiresIn = (Integer) responseBody.get("expires_in");

                if (accessToken == null) {
                    throw new RuntimeException("Access token not found in response");
                }

                LocalDateTime expiryTime = LocalDateTime.now()
                        .plusSeconds(expiresIn != null ? expiresIn : 86400);

                return new TokenInfo(accessToken, expiryTime);
            } else {
                throw new RuntimeException("Failed to get access token. Status: " + response.getStatusCode());
            }

        } catch (Exception e) {
            logger.error("Critical error fetching Genesys access token", e);
            throw new RuntimeException("Failed to authenticate with Genesys API: " + e.getMessage(), e);
        }
    }

    private static class TokenInfo {
        private final String accessToken;
        private final LocalDateTime expiryTime;

        public TokenInfo(String accessToken, LocalDateTime expiryTime) {
            this.accessToken = accessToken;
            this.expiryTime = expiryTime;
        }

        public String getAccessToken() { return accessToken; }
        public LocalDateTime getExpiryTime() { return expiryTime; }
    }
}


@PostMapping("/{conversationId}/complete-wrapup")
public ResponseEntity<Map<String, String>> completeWrapupFlow(
        @PathVariable String conversationId,
        @RequestBody WrapupRequest wrapupRequest) {

    try {
        genesysSdkService.executeCompleteWrapupFlow(conversationId, wrapupRequest);

        Map<String, String> response = new HashMap<>();
        response.put("status", "success");
        response.put("message", "Complete wrapup flow executed successfully");
        response.put("conversationId", conversationId);

        return ResponseEntity.ok(response);

    } catch (GenesysIntegrationException e) {
        logger.error("Genesys integration error in complete wrapup flow: {}", e.getMessage());
        Map<String, String> errorResponse = new HashMap<>();
        errorResponse.put("status", "error");
        errorResponse.put("message", e.getMessage());
        errorResponse.put("conversationId", conversationId);
        return ResponseEntity.status(e.getHttpStatus()).body(errorResponse);
    } catch (Exception e) {
        logger.error("Unexpected error in complete wrapup flow: {}", e.getMessage());
        Map<String, String> errorResponse = new HashMap<>();
        errorResponse.put("status", "error");
        errorResponse.put("message", "Internal server error");
        errorResponse.put("conversationId", conversationId);
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(errorResponse);
    }
}

<dependency>
    <groupId>com.mypurecloud</groupId>
    <artifactId>platform-client-v2</artifactId>
    <version>122.0.0</version> <!-- Check for latest version -->
</dependency>









curl --location --request PATCH 'https://api.aps1.pure.cloud/api/v2/conversations/callbacks/caeee5d5-0053-459e-b179-db529255c2f7/participants/285e99d1-c459-4b43-843d-89afa4ea5791' \
--header 'Content-Type: application/json' \
--header 'Authorization: Bearer 9pWOhdOzWA8FAyo2ynut03sGEckM1XjFl6J8uNnTSk1s64e9An-RfVS8XboMunDQQ-IiqjlnoZqLBRg5YU6XXw' \
--data '{

  "wrapup": {

    "name": "Active",

    "code": "0b0f9b43-e274-4f02-82e6-319aa6eb62e8",

    "notes": "test"

  }

}



{
	"info": {
		"_postman_id": "0a977916-427e-4b43-83f5-68422b842bd4",
		"name": "New Collection",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json",
		"_exporter_id": "46221664"
	},
	"item": [
		{
			"name": "Contact Copy",
			"request": {
				"auth": {
					"type": "oauth2",
					"oauth2": [
						{
							"key": "grant_type",
							"value": "client_credentials",
							"type": "string"
						},
						{
							"key": "clientSecret",
							"value": "RWiJFK5-ZUA2K0MC8Xz1FH2Tlv-n3IwngEaCNwTtOWg",
							"type": "string"
						},
						{
							"key": "clientId",
							"value": "4e3f814d-303d-4eea-855c-f6325a51812d",
							"type": "string"
						},
						{
							"key": "accessTokenUrl",
							"value": "https://login.aps1.pure.cloud/oauth/token",
							"type": "string"
						},
						{
							"key": "addTokenTo",
							"value": "header",
							"type": "string"
						}
					]
				},
				"method": "PATCH",
				"header": [],
				"body": {
					"mode": "raw",
					"raw": "{\r\n\r\n  \"wrapup\": {\r\n\r\n    \"name\": \"Active\",\r\n\r\n    \"code\": \"0b0f9b43-e274-4f02-82e6-319aa6eb62e8\",\r\n\r\n    \"notes\": \"test\"\r\n\r\n  }\r\n\r\n}\r\n ",
					"options": {
						"raw": {
							"language": "json"
						}
					}
				},
				"url": {
					"raw": "https://api.aps1.pure.cloud/api/v2/conversations/callbacks/caeee5d5-0053-459e-b179-db529255c2f7/participants/285e99d1-c459-4b43-843d-89afa4ea5791",
					"protocol": "https",
					"host": [
						"api",
						"aps1",
						"pure",
						"cloud"
					],
					"path": [
						"api",
						"v2",
						"conversations",
						"callbacks",
						"caeee5d5-0053-459e-b179-db529255c2f7",
						"participants",
						"285e99d1-c459-4b43-843d-89afa4ea5791"
					]
				}
			},
			"response": []
		}
	]
}
 '





































package com.demsIB.integration.genesys.service.impl;

import com.demsIB.integration.genesys.config.GenesysProperties;
import com.demsIB.integration.genesys.exception.GenesysAuthenticationException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.http.*;
import org.springframework.stereotype.Service;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MultiValueMap;
import org.springframework.web.client.RestTemplate;

import java.time.LocalDateTime;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.locks.ReentrantLock;

@Service
public class GenesysAuthService {

    private static final Logger logger = LoggerFactory.getLogger(GenesysAuthService.class);

    private final RestTemplate restTemplate;
    private final GenesysProperties genesysProperties;
    
    private final Map<String, TokenInfo> tokenCache = new ConcurrentHashMap<>();
    private final ReentrantLock tokenLock = new ReentrantLock();
    private static final String SYSTEM_TOKEN_KEY = "SYSTEM";

    public GenesysAuthService(@Qualifier("genesysRestTemplate") RestTemplate restTemplate,
                              GenesysProperties genesysProperties) {
        this.restTemplate = restTemplate;
        this.genesysProperties = genesysProperties;
    }

    // Get access token using client credentials flow (same as Postman)
    public String getAccessToken() {
        tokenLock.lock();
        try {
            TokenInfo tokenInfo = tokenCache.get(SYSTEM_TOKEN_KEY);
            
            if (tokenInfo == null || isTokenExpiredOrExpiring(tokenInfo)) {
                logger.info("Fetching new access token using client credentials flow");
                tokenInfo = fetchNewToken();
                tokenCache.put(SYSTEM_TOKEN_KEY, tokenInfo);
                logger.info("New access token acquired, expires at: {}", tokenInfo.getExpiryTime());
            } else {
                logger.debug("Using cached access token");
            }
            
            return tokenInfo.getAccessToken();
            
        } finally {
            tokenLock.unlock();
        }
    }

    private boolean isTokenExpiredOrExpiring(TokenInfo tokenInfo) {
        LocalDateTime refreshThreshold = tokenInfo.getExpiryTime()
                .minusMinutes(genesysProperties.getTokenRefreshThresholdMinutes());
        return LocalDateTime.now().isAfter(refreshThreshold);
    }

    private TokenInfo fetchNewToken() {
        try {
            HttpHeaders headers = new HttpHeaders();
            headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);

            MultiValueMap<String, String> body = new LinkedMultiValueMap<>();
            body.add("grant_type", "client_credentials");
            body.add("client_id", genesysProperties.getClientId());
            body.add("client_secret", genesysProperties.getClientSecret());

            HttpEntity<MultiValueMap<String, String>> requestEntity = new HttpEntity<>(body, headers);

            ResponseEntity<Map> response = restTemplate.exchange(
                    genesysProperties.getTokenUrl(),
                    HttpMethod.POST,
                    requestEntity,
                    Map.class
            );

            if (response.getStatusCode().is2xxSuccessful() && response.getBody() != null) {
                Map<String, Object> responseBody = response.getBody();
                String accessToken = (String) responseBody.get("access_token");
                String tokenType = (String) responseBody.get("token_type");
                Integer expiresIn = (Integer) responseBody.get("expires_in");

                if (accessToken == null) {
                    throw new GenesysAuthenticationException("Access token not found in response");
                }

                if (!"bearer".equalsIgnoreCase(tokenType)) {
                    logger.warn("Unexpected token type: {}", tokenType);
                }

                // Calculate expiry time
                LocalDateTime expiryTime = LocalDateTime.now()
                        .plusSeconds(expiresIn != null ? expiresIn : 86400);

                logger.info("Successfully obtained access token. Expires in: {} seconds", expiresIn);
                return new TokenInfo(accessToken, expiryTime);
                
            } else {
                throw new GenesysAuthenticationException("Failed to get access token. Status: " + response.getStatusCode());
            }

        } catch (Exception e) {
            logger.error("Error fetching Genesys access token", e);
            throw new GenesysAuthenticationException("Failed to authenticate with Genesys: " + e.getMessage(), e);
        }
    }

    public void invalidateToken() {
        tokenLock.lock();
        try {
            tokenCache.remove(SYSTEM_TOKEN_KEY);
            logger.info("Token invalidated");
        } finally {
            tokenLock.unlock();
        }
    }

    private static class TokenInfo {
        private final String accessToken;
        private final LocalDateTime expiryTime;

        public TokenInfo(String accessToken, LocalDateTime expiryTime) {
            this.accessToken = accessToken;
            this.expiryTime = expiryTime;
        }

        public String getAccessToken() { return accessToken; }
        public LocalDateTime getExpiryTime() { return expiryTime; }
    }
}



package com.demsIB.integration.genesys.service.impl;

import com.demsIB.integration.genesys.config.GenesysProperties;
import com.demsIB.integration.genesys.dto.request.WrapupRequest;
import com.demsIB.integration.genesys.dto.response.WrapupFinalResponse;
import com.demsIB.integration.genesys.exception.GenesysIntegrationException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.http.*;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

import java.util.Map;
import java.util.HashMap;

@Service
public class GenesysRestService {

    private static final Logger logger = LoggerFactory.getLogger(GenesysRestService.class);

    private final RestTemplate restTemplate;
    private final GenesysProperties genesysProperties;
    private final GenesysAuthService genesysAuthService;

    public GenesysRestService(@Qualifier("genesysRestTemplate") RestTemplate restTemplate,
                             GenesysProperties genesysProperties,
                             GenesysAuthService genesysAuthService) {
        this.restTemplate = restTemplate;
        this.genesysProperties = genesysProperties;
        this.genesysAuthService = genesysAuthService;
    }

    // Update participant wrapup using REST template (same as Postman)
    public void updateParticipantWrapup(String conversationId, String participantId, 
                                       WrapupFinalResponse wrapupRequest) {
        try {
            // Get fresh access token
            String accessToken = genesysAuthService.getAccessToken();
            
            HttpHeaders headers = new HttpHeaders();
            headers.setContentType(MediaType.APPLICATION_JSON);
            headers.setBearerAuth(accessToken);
            
            // Create request entity with headers and body
            HttpEntity<WrapupFinalResponse> requestEntity = new HttpEntity<>(wrapupRequest, headers);
            
            // Build the exact same URL as Postman
            String url = genesysProperties.getBaseUrl() + 
                "/api/v2/conversations/callbacks/" + conversationId + 
                "/participants/" + participantId;
            
            logger.info("Making PATCH request to: {}", url);
            logger.info("Request body: {}", wrapupRequest);
            
            // Make the PATCH request
            ResponseEntity<String> response = restTemplate.exchange(
                url, 
                HttpMethod.PATCH, 
                requestEntity, 
                String.class
            );
            
            if (response.getStatusCode().is2xxSuccessful()) {
                logger.info("Successfully updated participant wrapup. Response: {}", response.getBody());
            } else {
                throw new GenesysIntegrationException(
                    "Failed to update participant wrapup. Status: " + response.getStatusCode(), 
                    response.getStatusCodeValue()
                );
            }
            
        } catch (Exception e) {
            logger.error("Error updating participant wrapup: {}", e.getMessage());
            throw new GenesysIntegrationException("Failed to update participant wrapup: " + e.getMessage(), 500);
        }
    }

    // Complete flow using REST calls
    public void executeCompleteWrapupFlow(String conversationId, WrapupRequest wrapupRequest) {
        try {
            logger.info("Starting complete wrapup flow for conversation: {}", conversationId);
            
            // Step 1: Get agent participant info
            Map<String, String> agentInfo = getAgentParticipantInfo(conversationId);
            String participantId = agentInfo.get("participantId");
            
            logger.info("Found agent participant: {}", participantId);
            
            // Step 2: Get wrap-up codes and find matching code
            String wrapupCodeId = findWrapupCodeId(conversationId, participantId, wrapupRequest.getName());
            
            logger.info("Found wrapup code ID: {} for name: {}", wrapupCodeId, wrapupRequest.getName());
            
            // Step 3: Create wrapup request (same as Postman)
            WrapupFinalResponse wrapupFinalRequest = createWrapupFinalRequest(wrapupRequest, wrapupCodeId);
            
            // Step 4: Update participant wrapup
            updateParticipantWrapup(conversationId, participantId, wrapupFinalRequest);
            
            logger.info("Complete wrapup flow finished successfully");
            
        } catch (Exception e) {
            logger.error("Error in complete wrapup flow: {}", e.getMessage());
            throw new GenesysIntegrationException("Complete wrapup flow failed: " + e.getMessage(), 500);
        }
    }

    private Map<String, String> getAgentParticipantInfo(String conversationId) {
        // Implement this based on your existing logic
        // This should call the analytics API to get participant details
        Map<String, String> agentInfo = new HashMap<>();
        agentInfo.put("participantId", "285e99d1-c459-4b43-843d-89afa4ea5791"); // Hardcoded for testing
        return agentInfo;
    }

    private String findWrapupCodeId(String conversationId, String participantId, String wrapupName) {
        // Implement this based on your existing logic  
        // This should call the wrapupcodes API
        return "0b0f9b43-e274-4f02-82e6-319aa6eb62e8"; // Hardcoded for testing
    }

    private WrapupFinalResponse createWrapupFinalRequest(WrapupRequest wrapupRequest, String wrapupCodeId) {
        WrapupFinalResponse finalResponse = new WrapupFinalResponse();
        
        // Create the exact same structure as Postman
        WrapupFinalResponse.WrapupDetails wrapupDetails = new WrapupFinalResponse.WrapupDetails();
        wrapupDetails.setName(wrapupRequest.getName());
        wrapupDetails.setCode(wrapupCodeId);
        wrapupDetails.setNotes(wrapupRequest.getNotes());
        
        finalResponse.setWrapup(wrapupDetails);
        
        return finalResponse;
    }
}



package com.demsIB.integration.genesys.dto.response;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@AllArgsConstructor
@NoArgsConstructor
@Getter
@Setter
public class WrapupFinalResponse {
    private WrapupDetails wrapup;

    @AllArgsConstructor
    @NoArgsConstructor
    @Getter
    @Setter
    public static class WrapupDetails {
        private String name;
        private String code;
        private String notes;
    }
}


@RestController
@RequestMapping("/api/v2/conversations/calls")
public class GenesysConversationController {

    private final GenesysRestService genesysRestService;
    private final Logger logger = LoggerFactory.getLogger(GenesysConversationController.class);

    public GenesysConversationController(GenesysRestService genesysRestService) {
        this.genesysRestService = genesysRestService;
    }

    @PatchMapping("/{conversationId}/participants/{participantId}")
    public ResponseEntity<Map<String, String>> updateParticipantWrapup(
            @PathVariable String conversationId,
            @PathVariable String participantId,
            @RequestBody WrapupFinalResponse wrapupRequest) {

        try {
            logger.info("Received PATCH request for conversation: {}, participant: {}", 
                       conversationId, participantId);
            
            genesysRestService.updateParticipantWrapup(conversationId, participantId, wrapupRequest);

            Map<String, String> response = new HashMap<>();
            response.put("status", "success");
            response.put("message", "Participant wrapup updated successfully");
            response.put("conversationId", conversationId);
            response.put("participantId", participantId);

            return ResponseEntity.ok(response);

        } catch (Exception e) {
            logger.error("Error updating participant wrapup: {}", e.getMessage());
            Map<String, String> errorResponse = new HashMap<>();
            errorResponse.put("status", "error");
            errorResponse.put("message", e.getMessage());
            errorResponse.put("conversationId", conversationId);
            errorResponse.put("participantId", participantId);

            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(errorResponse);
        }
    }

    @PostMapping("/{conversationId}/complete-wrapup")
    public ResponseEntity<Map<String, String>> completeWrapupFlow(
            @PathVariable String conversationId,
            @RequestBody WrapupRequest wrapupRequest) {

        try {
            genesysRestService.executeCompleteWrapupFlow(conversationId, wrapupRequest);

            Map<String, String> response = new HashMap<>();
            response.put("status", "success");
            response.put("message", "Complete wrapup flow executed successfully");
            response.put("conversationId", conversationId);

            return ResponseEntity.ok(response);

        } catch (Exception e) {
            logger.error("Error in complete wrapup flow: {}", e.getMessage());
            Map<String, String> errorResponse = new HashMap<>();
            errorResponse.put("status", "error");
            errorResponse.put("message", e.getMessage());
            errorResponse.put("conversationId", conversationId);

            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(errorResponse);
        }
    }
}


# Genesys Configuration
genesys.conversation.base-url=https://api.aps1.pure.cloud
genesys.conversation.token-url=https://login.aps1.pure.cloud/oauth/token
genesys.conversation.client-id=4e3f814d-303d-4eea-855c-f6325a51812d
genesys.conversation.client-secret=RWiJFK5-ZUA2K0MC8Xz1FH2Tlv-n3IwngEaCNwTtOWg
genesys.conversation.api-timeout-seconds=30
