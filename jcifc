package com.demsIB.integration.bank.service;

import com.demsIB.integration.bank.dto.request.DispositionDumpDTO;
import com.demsIB.integration.bank.dto.request.BankReportDTO;
import jcifs.CIFSContext;
import jcifs.Config;
import jcifs.config.PropertyConfiguration;
import jcifs.context.BaseContext;
import jcifs.context.SingletonContext;
import jcifs.smb.NtlmPasswordAuthentication;
import jcifs.smb.NtlmPasswordAuthenticator;
import jcifs.smb.SmbFile;
import jcifs.smb.SmbFileOutputStream;
import org.apache.poi.ss.usermodel.Workbook;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;

import java.io.*;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.List;

@Service
public class ReportSchedulerService {

    private final Logger logger = LoggerFactory.getLogger("BANK_REPORT_LOGGER");

    private final BankReportExcelService excelReportService;
    private final ReportService reportService;
    private final DispositionDumpExcelService dispositionDumpExcelService;

    public ReportSchedulerService(BankReportExcelService excelReportService, ReportService reportService, DispositionDumpExcelService dispositionDumpExcelService) {
        this.excelReportService = excelReportService;
        this.reportService = reportService;
        this.dispositionDumpExcelService = dispositionDumpExcelService;
        setupJcifsConfiguration();
    }

    @Value("${reports.networkPath}")
    private String networkPathUrl;

    @Value("${bank.report.name}")
    private String bankReportName;

    @Value("${disposition-dump.report.name}")
    private String dispositionDumpReportName;

    @Value("${reports.username}")
    private String username;

    @Value("${reports.password}")
    private String password;

    @Value("${reports.domain}")
    private String domain;

    private void setupJcifsConfiguration() {
        System.setProperty("jcifs.smb.client.disablePlainTextPasswords", "false");
        System.setProperty("jcifs.smb.client.soTimeout", "120000"); // 2 minutes
        System.setProperty("jcifs.smb.client.connTimeout", "30000"); // 30 seconds
        System.setProperty("jcifs.smb.client.enableExtendedSecurity", "false");

        System.setProperty("jcifs.smb.client.guestAccess", "true");
        System.setProperty("jcifs.smb.client.useExtendedSecurity", "false");

        logger.info("JCIFS configured for anonymous/guest access");
    }

    private CIFSContext createCifsContext() {
        CIFSContext context = SingletonContext.getInstance();

        NtlmPasswordAuthenticator authenticator = new NtlmPasswordAuthenticator(domain,username,password);
        logger.info("CIFS context created with credentials: {}", authenticator);
        return context.withCredentials(authenticator);
    }

    private String normalizeNetworkPath(String fileName) {
        String normalizedPath = networkPathUrl.trim();

        logger.info("Original network path: {}", normalizedPath);

        if (normalizedPath.startsWith("\\\\")) {
            normalizedPath = "smb:" + normalizedPath.replace("\\", "/");
        } else if (!normalizedPath.startsWith("smb://")) {
            normalizedPath = "smb://" + normalizedPath.replace("\\", "/");
        }

        if (!normalizedPath.endsWith("/")) {
            normalizedPath += "/";
        }

        String fullPath = normalizedPath + fileName;
        logger.info("Normalized JCIFS path: {}", fullPath);

        return fullPath;
    }

    private boolean testNetworkConnection(CIFSContext context) {
        try {
            String testPath = normalizeNetworkPath("").replaceAll("[^/]+$", "");
            SmbFile smbDir = new SmbFile(testPath, context);

            logger.info("Testing connection to: {}", testPath);

            if (smbDir.exists()) {
                logger.info("Network path is accessible: {}", testPath);

                SmbFile testFile = new SmbFile(testPath + "test_write_access.tmp", context);
                try (OutputStream out = new SmbFileOutputStream(testFile)) {
                    out.write("test".getBytes());
                    logger.info("Write permission confirmed");
                }
                testFile.delete();

                return true;
            } else {
                logger.warn("Network path does not exist or is not accessible: {}", testPath);
                return false;
            }
        } catch (Exception e) {
            logger.error("Network connection test failed", e);
            return false;
        }
    }

    private void saveExcelToNetworkShare(Workbook workbook, String fileName) throws Exception {
        CIFSContext context = createCifsContext();
        String fullSmbPath = normalizeNetworkPath(fileName);

        logger.info("Attempting to save file via JCIFS (anonymous access) to: {}", fullSmbPath);

        SmbFile smbFile = null;
        try {
            if (!testNetworkConnection(context)) {
                throw new Exception("Network path is not accessible. Please check share permissions.");
            }

            smbFile = new SmbFile(fullSmbPath, context);

            SmbFile parentDir = new SmbFile(smbFile.getParent(), context);
            if (!parentDir.exists()) {
                logger.info("Creating directory: {}", parentDir.getPath());
                parentDir.mkdirs();
                Thread.sleep(500);
            }

            try (OutputStream out = new SmbFileOutputStream(smbFile);
                 BufferedOutputStream bufferedOut = new BufferedOutputStream(out)) {

                workbook.write(bufferedOut);
                bufferedOut.flush();

                logger.info("Excel file successfully saved to network share: {}", fullSmbPath);

                if (smbFile.exists() && smbFile.length() > 0) {
                    logger.info("File verification successful. Size: {} bytes", smbFile.length());
                }
            }

        } catch (Exception e) {
            logger.error("JCIFS operation failed for path: {}", fullSmbPath, e);

            String errorMessage = "Failed to save report: " + e.getMessage();
            if (e.getMessage().contains("Access is denied")) {
                errorMessage += ". Please check share permissions for anonymous/guest access.";
            } else if (e.getMessage().contains("Network path not found")) {
                errorMessage += ". Please verify the network path and share name.";
            }

            throw new Exception(errorMessage, e);
        } finally {
            if (workbook != null) {
                try {
                    workbook.close();
                } catch (Exception e) {
                    logger.warn("Error closing workbook", e);
                }
            }
        }
    }

    @Scheduled(cron = "${report.scheduler.time}")
    public void generateBankReport() {
        try {
            logger.info("Starting Block_Unblock_Dump report generation");
            LocalDate startDate = LocalDate.now().minusDays(1);
            LocalDate endDate = LocalDate.now().minusDays(1);
            List<BankReportDTO> reports = reportService.getReportsByDateRange(startDate, endDate);
            if (reports.isEmpty()) {
                logger.warn("No data found for date range: {} to {}", startDate, endDate);
            }
            Workbook workbook = excelReportService.generateExcelReport(reports, startDate, endDate);
            String filename = bankReportName + startDate + "_to_" + endDate + ".xlsx";
            saveExcelToNetworkShare(workbook, filename);
            logger.info("Block_Unblock_Dump report generated successfully: {}", filename);
        } catch (Exception e) {
            logger.error("Failed to generate Block_Unblock_Dump report", e);
        }
    }

    @Scheduled(cron = "${disposition-dump.scheduler.time}")
    public void generateDispositionDumpReport() {
        try {
            logger.info("Generating Disposition Dump report");
            LocalDateTime startDate = LocalDateTime.now().minusDays(1).withHour(0).withMinute(0);
            LocalDateTime endDate = LocalDateTime.now().minusDays(1).withHour(23).withMinute(59);
            List<DispositionDumpDTO> reports = reportService.getDispositionDumpByDateRange(startDate, endDate);
            if (reports.isEmpty()) {
                logger.warn("No data found for date range: {} to {}", startDate, endDate);
            }
            Workbook workbook = dispositionDumpExcelService.generateExcelReport(reports, startDate, endDate);
            String filename = dispositionDumpReportName +
                    startDate.format(DateTimeFormatter.ofPattern("yyyyMMdd")) + "_to_" +
                    endDate.format(DateTimeFormatter.ofPattern("yyyyMMdd")) + ".xlsx";
            saveExcelToNetworkShare(workbook, filename);
            logger.info("Disposition Dump report generated successfully");
        } catch (Exception e) {
            logger.error("Failed to generate Disposition Dump report", e);
        }
    }

    public String testConnection() {
        try {
            CIFSContext context = createCifsContext();
            boolean isConnected = testNetworkConnection(context);

            if (isConnected) {
                return "SUCCESS: Network share is accessible with anonymous/guest access";
            } else {
                return "FAILED: Cannot access network share";
            }
        } catch (Exception e) {
            return "ERROR testing connection: " + e.getMessage();
        }
    }
}



25-09-25 16:15:35.181 [Transport0] WARN  jcifs.smb.SmbTransportImpl - Disconnecting transport while still in use Transport0[AZIBDRCRMDBUAT/10.68.3.23:445,state=5,signingEnforced=false,usage=3]: [SmbSession[credentials=,targetHost=azibdrcrmdbuat,targetDomain=null,uid=0,connectionState=0,usage=3]]



bank.report.name=Block_Unblock_Dump__
report.query=SELECT interaction_id, call_id, agent_id, product_category, sub_category,resolution_code, date, time, mobile_number_last_4_digit, created_by FROM ib_bank_report WHERE date BETWEEN ? AND ?
report.columns= interaction_id,call_id,agent_id,product_category,sub_category,resolution_code,date,time,mobile_number_last_4_digit,created_by
report.headers= Interaction ID,Call ID,Agent ID,Product Category,Sub Category,Resolution Code,Date,Time,Mobile Last 4 Digits, Created By
report.scheduler.time=0 39 14 * * *

disposition-dump.report.name=DispositionDumpReport__
disposition-dump.query=SELECT um.login_id, sd.created_on, sd.created_by, sd.call_id, cm4.name AS Ticket_Type, cm3.name AS Category, cm2.name AS SubCategory, cm1.name AS Product_Category, sm.status_name AS Resolution_code FROM ib_service_details sd LEFT JOIN ib_category_master cm1 ON sd.category_id = cm1.category_id LEFT JOIN ib_category_master cm2 ON cm1.pid = cm2.category_id LEFT JOIN ib_category_master cm3 ON cm2.pid = cm3.category_id LEFT JOIN ib_category_master cm4 ON cm3.pid = cm4.category_id LEFT JOIN ib_status_master sm ON sd.status_id = sm.status_id LEFT JOIN ib_user_master um ON sd.created_by = um.user_id WHERE sd.call_id IS NOT NULL AND sd.call_id <> '' AND sd.created_on BETWEEN ? AND ? ORDER BY sd.created_on DESC
disposition-dump.columns=login_id,created_on,created_by,call_id,Ticket_Type,Category,SubCategory,Product_Category,Resolution_code
disposition-dump.headers=Login ID,Created On,Created BY,Call ID,Ticket Type,Category,SubCategory,Product Category,Resolution Code
disposition-dump.scheduler.time=0 39 14 * * *
reports.networkPath=\\\\AZIBDRCRMDBUAT\\Reports\\
#reports.networkPath=C:\\Reports\\

reports.username=
reports.password=
reports.domain=










































package com.demsIB.integration.bank.service;

import com.demsIB.integration.bank.dto.request.DispositionDumpDTO;
import com.demsIB.integration.bank.dto.request.BankReportDTO;
import jcifs.CIFSContext;
import jcifs.Config;
import jcifs.config.PropertyConfiguration;
import jcifs.context.BaseContext;
import jcifs.context.SingletonContext;
import jcifs.smb.NtlmPasswordAuthentication;
import jcifs.smb.NtlmPasswordAuthenticator;
import jcifs.smb.SmbFile;
import jcifs.smb.SmbFileOutputStream;
import org.apache.poi.ss.usermodel.Workbook;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;

import java.io.*;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.List;
import java.util.concurrent.atomic.AtomicReference;

@Service
public class ReportSchedulerService {

    private final Logger logger = LoggerFactory.getLogger("BANK_REPORT_LOGGER");

    private final BankReportExcelService excelReportService;
    private final ReportService reportService;
    private final DispositionDumpExcelService dispositionDumpExcelService;
    
    private final AtomicReference<CIFSContext> cifsContextRef = new AtomicReference<>();

    public ReportSchedulerService(BankReportExcelService excelReportService, 
                                 ReportService reportService, 
                                 DispositionDumpExcelService dispositionDumpExcelService) {
        this.excelReportService = excelReportService;
        this.reportService = reportService;
        this.dispositionDumpExcelService = dispositionDumpExcelService;
        setupJcifsConfiguration();
    }

    @Value("${reports.networkPath}")
    private String networkPathUrl;

    @Value("${bank.report.name}")
    private String bankReportName;

    @Value("${disposition-dump.report.name}")
    private String dispositionDumpReportName;

    @Value("${reports.username}")
    private String username;

    @Value("${reports.password}")
    private String password;

    @Value("${reports.domain}")
    private String domain;

    private void setupJcifsConfiguration() {
        // Improved JCIFS configuration
        System.setProperty("jcifs.smb.client.disablePlainTextPasswords", "false");
        System.setProperty("jcifs.smb.client.soTimeout", "120000"); // 2 minutes
        System.setProperty("jcifs.smb.client.connTimeout", "30000"); // 30 seconds
        System.setProperty("jcifs.smb.client.responseTimeout", "60000"); // 1 minute
        
        // Connection reuse settings
        System.setProperty("jcifs.smb.client.connTimeout", "10000");
        System.setProperty("jcifs.smb.client.keepAlive", "true");
        System.setProperty("jcifs.smb.client.keepAliveResponseTimeout", "5000");
        System.setProperty("jcifs.smb.client.keepAliveExpiration", "300000"); // 5 minutes
        System.setProperty("jcifs.smb.client.sessionTimeout", "300000"); // 5 minutes
        
        // Disable extended security for better compatibility
        System.setProperty("jcifs.smb.client.enableExtendedSecurity", "false");
        System.setProperty("jcifs.smb.client.useExtendedSecurity", "false");
        System.setProperty("jcifs.smb.client.guestAccess", "true");

        logger.info("JCIFS configured with connection pooling settings");
    }

    private synchronized CIFSContext getCifsContext() {
        CIFSContext context = cifsContextRef.get();
        if (context == null) {
            context = createCifsContext();
            cifsContextRef.set(context);
        }
        return context;
    }

    private CIFSContext createCifsContext() {
        try {
            // Use BaseContext for better control over configuration
            PropertyConfiguration config = new PropertyConfiguration(System.getProperties());
            BaseContext context = new BaseContext(config);
            
            if (username != null && !username.trim().isEmpty() && 
                password != null && !password.trim().isEmpty()) {
                NtlmPasswordAuthenticator authenticator = new NtlmPasswordAuthenticator(
                    domain, username, password);
                logger.info("CIFS context created with credentials for domain: {}", domain);
                return context.withCredentials(authenticator);
            } else {
                logger.info("CIFS context created with anonymous access");
                return context.withAnonymousCredentials();
            }
        } catch (Exception e) {
            logger.error("Failed to create CIFS context, using singleton", e);
            return SingletonContext.getInstance().withAnonymousCredentials();
        }
    }

    private String normalizeNetworkPath(String fileName) {
        String normalizedPath = networkPathUrl.trim();

        logger.info("Original network path: {}", normalizedPath);

        if (normalizedPath.startsWith("\\\\")) {
            normalizedPath = "smb:" + normalizedPath.replace("\\", "/");
        } else if (!normalizedPath.startsWith("smb://")) {
            normalizedPath = "smb://" + normalizedPath.replace("\\", "/");
        }

        if (!normalizedPath.endsWith("/")) {
            normalizedPath += "/";
        }

        String fullPath = normalizedPath + fileName;
        logger.info("Normalized JCIFS path: {}", fullPath);

        return fullPath;
    }

    private boolean testNetworkConnection(CIFSContext context) {
        SmbFile smbDir = null;
        SmbFile testFile = null;
        
        try {
            String testPath = normalizeNetworkPath("").replaceAll("[^/]+$", "");
            smbDir = new SmbFile(testPath, context);

            logger.info("Testing connection to: {}", testPath);

            if (smbDir.exists()) {
                logger.info("Network path is accessible: {}", testPath);

                // Test write permission
                testFile = new SmbFile(testPath + "test_write_access_" + System.currentTimeMillis() + ".tmp", context);
                try (OutputStream out = new SmbFileOutputStream(testFile)) {
                    out.write("test".getBytes());
                    logger.info("Write permission confirmed");
                }
                
                // Clean up test file
                if (testFile.exists()) {
                    testFile.delete();
                }

                return true;
            } else {
                logger.warn("Network path does not exist or is not accessible: {}", testPath);
                return false;
            }
        } catch (Exception e) {
            logger.error("Network connection test failed", e);
            return false;
        } finally {
            // Ensure resources are closed
            closeSmbFileQuietly(testFile);
            closeSmbFileQuietly(smbDir);
        }
    }

    private void closeSmbFileQuietly(SmbFile file) {
        if (file != null) {
            try {
                // For SmbFile, we need to ensure the underlying stream is closed
                // This helps prevent the "transport still in use" warning
                if (file.getInputStream() != null) {
                    file.getInputStream().close();
                }
            } catch (Exception e) {
                // Ignore cleanup exceptions
            }
        }
    }

    private void saveExcelToNetworkShare(Workbook workbook, String fileName) throws Exception {
        CIFSContext context = getCifsContext();
        String fullSmbPath = normalizeNetworkPath(fileName);

        logger.info("Attempting to save file via JCIFS to: {}", fullSmbPath);

        SmbFile smbFile = null;
        try {
            if (!testNetworkConnection(context)) {
                throw new Exception("Network path is not accessible. Please check share permissions.");
            }

            smbFile = new SmbFile(fullSmbPath, context);

            // Create parent directory if it doesn't exist
            SmbFile parentDir = new SmbFile(smbFile.getParent(), context);
            if (!parentDir.exists()) {
                logger.info("Creating directory: {}", parentDir.getPath());
                parentDir.mkdirs();
                // Short delay to ensure directory is created
                Thread.sleep(1000);
            }

            // Write workbook to network share
            try (OutputStream out = new SmbFileOutputStream(smbFile);
                 BufferedOutputStream bufferedOut = new BufferedOutputStream(out)) {

                workbook.write(bufferedOut);
                bufferedOut.flush();

                logger.info("Excel file successfully saved to network share: {}", fullSmbPath);

                // Verify file was written successfully
                if (smbFile.exists() && smbFile.length() > 0) {
                    logger.info("File verification successful. Size: {} bytes", smbFile.length());
                } else {
                    throw new Exception("File was created but appears to be empty or doesn't exist");
                }
            }

        } catch (Exception e) {
            logger.error("JCIFS operation failed for path: {}", fullSmbPath, e);

            String errorMessage = "Failed to save report: " + e.getMessage();
            if (e.getMessage().contains("Access is denied")) {
                errorMessage += ". Please check share permissions.";
            } else if (e.getMessage().contains("Network path not found")) {
                errorMessage += ". Please verify the network path and share name.";
            } else if (e.getMessage().contains("transport while still in use")) {
                errorMessage += ". Connection issue detected, retrying with new connection.";
                // Reset the context to force a new connection
                resetCifsContext();
            }

            throw new Exception(errorMessage, e);
        } finally {
            closeSmbFileQuietly(smbFile);
            closeWorkbook(workbook);
        }
    }

    private synchronized void resetCifsContext() {
        CIFSContext oldContext = cifsContextRef.get();
        if (oldContext != null) {
            try {
                // Properly close the old context
                if (oldContext instanceof AutoCloseable) {
                    ((AutoCloseable) oldContext).close();
                }
            } catch (Exception e) {
                logger.warn("Error closing old CIFS context", e);
            }
        }
        cifsContextRef.set(null);
        logger.info("CIFS context reset");
    }

    private void closeWorkbook(Workbook workbook) {
        if (workbook != null) {
            try {
                workbook.close();
            } catch (Exception e) {
                logger.warn("Error closing workbook", e);
            }
        }
    }

    @Scheduled(cron = "${report.scheduler.time}")
    public void generateBankReport() {
        try {
            logger.info("Starting Block_Unblock_Dump report generation");
            LocalDate startDate = LocalDate.now().minusDays(1);
            LocalDate endDate = LocalDate.now().minusDays(1);
            List<BankReportDTO> reports = reportService.getReportsByDateRange(startDate, endDate);
            if (reports.isEmpty()) {
                logger.warn("No data found for date range: {} to {}", startDate, endDate);
                return; // Skip file generation if no data
            }
            Workbook workbook = excelReportService.generateExcelReport(reports, startDate, endDate);
            String filename = bankReportName + startDate + "_to_" + endDate + ".xlsx";
            saveExcelToNetworkShare(workbook, filename);
            logger.info("Block_Unblock_Dump report generated successfully: {}", filename);
        } catch (Exception e) {
            logger.error("Failed to generate Block_Unblock_Dump report", e);
        }
    }

    @Scheduled(cron = "${disposition-dump.scheduler.time}")
    public void generateDispositionDumpReport() {
        try {
            logger.info("Generating Disposition Dump report");
            LocalDateTime startDate = LocalDateTime.now().minusDays(1).withHour(0).withMinute(0);
            LocalDateTime endDate = LocalDateTime.now().minusDays(1).withHour(23).withMinute(59);
            List<DispositionDumpDTO> reports = reportService.getDispositionDumpByDateRange(startDate, endDate);
            if (reports.isEmpty()) {
                logger.warn("No data found for date range: {} to {}", startDate, endDate);
                return; // Skip file generation if no data
            }
            Workbook workbook = dispositionDumpExcelService.generateExcelReport(reports, startDate, endDate);
            String filename = dispositionDumpReportName +
                    startDate.format(DateTimeFormatter.ofPattern("yyyyMMdd")) + "_to_" +
                    endDate.format(DateTimeFormatter.ofPattern("yyyyMMdd")) + ".xlsx";
            saveExcelToNetworkShare(workbook, filename);
            logger.info("Disposition Dump report generated successfully");
        } catch (Exception e) {
            logger.error("Failed to generate Disposition Dump report", e);
        }
    }

    public String testConnection() {
        try {
            CIFSContext context = getCifsContext();
            boolean isConnected = testNetworkConnection(context);

            if (isConnected) {
                return "SUCCESS: Network share is accessible";
            } else {
                return "FAILED: Cannot access network share";
            }
        } catch (Exception e) {
            return "ERROR testing connection: " + e.getMessage();
        }
    }
}


# SMB Configuration
reports.networkPath=\\\\AZIBDRCRMDBUAT\\Reports\\

# If using authentication (leave empty for anonymous)
reports.username=
reports.password=
reports.domain=

# JCIFS Timeout Settings
jcifs.smb.client.soTimeout=120000
jcifs.smb.client.connTimeout=30000
jcifs.smb.client.responseTimeout=60000
jcifs.smb.client.keepAlive=true
jcifs.smb.client.sessionTimeout=300000


































private void setupJcifsConfiguration() {
    // Clear any conflicting properties
    System.clearProperty("jcifs.smb.client.disablePlainTextPasswords");
    System.clearProperty("jcifs.smb.client.useExtendedSecurity");
    
    // Essential settings for Windows share access
    System.setProperty("jcifs.smb.client.disablePlainTextPasswords", "false");
    System.setProperty("jcifs.smb.client.soTimeout", "60000");
    System.setProperty("jcifs.smb.client.connTimeout", "30000");
    
    // Critical: Disable extended security for local Windows shares
    System.setProperty("jcifs.smb.client.useExtendedSecurity", "false");
    System.setProperty("jcifs.smb.client.enableExtendedSecurity", "false");
    
    // Enable guest access
    System.setProperty("jcifs.smb.client.guestAccess", "true");
    System.setProperty("jcifs.smb.client.allowGuestAccess", "true");
    
    // Use NTLM v1 for better compatibility
    System.setProperty("jcifs.smb.client.lmCompatibility", "0");
    
    // Disable SMB2 for better compatibility with JCIFS
    System.setProperty("jcifs.smb.client.enableSMB2", "false");
    
    logger.info("JCIFS configured for Windows share access");
}




private String normalizeNetworkPath(String fileName) {
    String normalizedPath = networkPathUrl.trim();
    
    logger.info("Original network path: {}", normalizedPath);
    
    // Handle Windows UNC path (\\server\share)
    if (normalizedPath.startsWith("\\\\")) {
        normalizedPath = "smb:" + normalizedPath.replace("\\", "/");
    }
    // Handle already normalized paths
    else if (!normalizedPath.startsWith("smb://")) {
        normalizedPath = "smb://" + normalizedPath.replace("\\", "/");
    }
    
    // Ensure it ends with /
    if (!normalizedPath.endsWith("/")) {
        normalizedPath += "/";
    }
    
    String fullPath = normalizedPath + fileName;
    logger.info("JCIFS Path: {}", fullPath);
    
    return fullPath;
}



private CIFSContext createCifsContext() {
    try {
        // Since Windows share works without credentials, use anonymous access
        logger.info("Creating CIFS context with anonymous access");
        
        // Use BaseContext for better configuration control
        PropertyConfiguration config = new PropertyConfiguration(System.getProperties());
        BaseContext context = new BaseContext(config);
        
        return context.withAnonymousCredentials();
        
    } catch (Exception e) {
        logger.error("Error creating CIFS context, using singleton", e);
        return SingletonContext.getInstance().withAnonymousCredentials();
    }
}


public String testConnection() {
    SmbFile smbDir = null;
    SmbFile testFile = null;
    
    try {
        CIFSContext context = createCifsContext();
        String testPath = normalizeNetworkPath("").replaceAll("[^/]+$", "");
        
        logger.info("=== JCIFS Connection Test ===");
        logger.info("Testing path: {}", testPath);
        logger.info("Context: {}", context);
        
        // Test directory access
        smbDir = new SmbFile(testPath, context);
        logger.info("SmbFile created: {}", smbDir);
        
        if (smbDir.exists()) {
            logger.info("✓ Path exists");
        } else {
            return "FAILED: Path does not exist: " + testPath;
        }
        
        if (smbDir.isDirectory()) {
            logger.info("✓ Is directory");
        } else {
            return "FAILED: Not a directory";
        }
        
        // Test write permission
        String testFileName = "jcifs_test_" + System.currentTimeMillis() + ".txt";
        testFile = new SmbFile(testPath + testFileName, context);
        logger.info("Test file: {}", testFile);
        
        try (SmbFileOutputStream out = new SmbFileOutputStream(testFile)) {
            out.write("JCIFS test content".getBytes());
            logger.info("✓ Write successful");
        }
        
        // Verify file was created
        if (testFile.exists() && testFile.length() > 0) {
            logger.info("✓ File verified - Size: {} bytes", testFile.length());
        } else {
            return "FAILED: File created but verification failed";
        }
        
        // Cleanup
        testFile.delete();
        logger.info("✓ Cleanup successful");
        
        return "SUCCESS: JCIFS can access and write to share";
        
    } catch (Exception e) {
        logger.error("!!! JCIFS TEST FAILED !!!", e);
        
        // Provide specific error messages
        if (e.getMessage().contains("Access is denied")) {
            return "ACCESS DENIED: Check share permissions. Try enabling guest access on the share.";
        } else if (e.getMessage().contains("Failed to connect")) {
            return "CONNECTION FAILED: Check network connectivity and share name.";
        } else if (e.getMessage().contains("The network path was not found")) {
            return "NETWORK PATH NOT FOUND: Verify share path and DNS resolution.";
        } else {
            return "ERROR: " + e.getClass().getSimpleName() + " - " + e.getMessage();
        }
    } finally {
        // Cleanup resources
        closeSmbFileQuietly(testFile);
        closeSmbFileQuietly(smbDir);
    }
}

private void closeSmbFileQuietly(SmbFile file) {
    if (file != null) {
        try {
            // Close any open streams
            if (file.getInputStream() != null) {
                file.getInputStream().close();
            }
        } catch (Exception e) {
            // Ignore cleanup errors
        }
    }
}



private void saveExcelWithJavaNio(Workbook workbook, String fileName) throws Exception {
    // Use the exact Windows UNC path that worked in your test
    String fullPath = "\\\\AZIBDRCRMDBUAT\\Reports\\" + fileName;
    
    logger.info("Saving file using Java NIO: {}", fullPath);
    
    Path path = Paths.get(fullPath);
    
    // Create parent directories if needed
    Files.createDirectories(path.getParent());
    
    try (OutputStream out = Files.newOutputStream(path);
         BufferedOutputStream bufferedOut = new BufferedOutputStream(out)) {
        
        workbook.write(bufferedOut);
        bufferedOut.flush();
        
        logger.info("✓ File saved successfully: {}", fullPath);
        
        // Verify file was created
        if (Files.exists(path) && Files.size(path) > 0) {
            logger.info("✓ File verification passed - Size: {} bytes", Files.size(path));
        }
    } finally {
        workbook.close();
    }
}
